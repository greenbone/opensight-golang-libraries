![Greenbone Logo](https://www.greenbone.net/wp-content/uploads/gb_new-logo_horizontal_rgb_small.png)

# jobQueue Package Documentation

This package provides a job queue that can be used to execute a function in a thread-safe manner. The job queue is designed to be used in situations where multiple requests of the same type need to be processed, but only one request can be processed at a time.

## Example Usage

Here is an example of how to use the job queue:

```go
package main

import (
	"context"
	"fmt"
	"time"

	"github.com/greenbone/opensight-golang-libraries/jobQueue"
)

func main() {
	// Define the function that will be executed for each request
	execFunc := func() error {
		fmt.Println("Processing request")
		return nil
	}

	// Create a new job queue with the defined function and a context with a 5 second timeout
	q := jobQueue.NewJobQueue(execFunc, context.WithTimeout(context.Background(), 5*time.Second))

	// Add several requests to the queue
	for i := 0; i < 10; i++ {
		req := jobQueue.Request{ID: fmt.Sprintf("Request %d", i)}
		q.AddQueueRequest(req)
	}

	// Wait for the queue to finish processing all requests
	q.Wait()
}
```

In this example, 10 requests are added to the queue, and the function is executed for each request one after the other. The Wait function is called to wait for all requests to be processed before the 
program exits.

---

<!-- gomarkdoc:embed:start -->

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# jobQueue

```go
import "github.com/greenbone/opensight-golang-libraries/pkg/jobQueue"
```

## Index

- [type Request](<#Request>)


<a name="Request"></a>
## type [Request](<https://github.com/greenbone/opensight-golang-libraries/blob/main/pkg/jobQueue/jobQueue.go#L15-L17>)



```go
type Request struct {
    ID string
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)


<!-- gomarkdoc:embed:end -->

# License

Copyright (C) 2022-2023 [Greenbone AG][Greenbone AG]

Licensed under the [GNU General Public License v3.0 or later](../../LICENSE).