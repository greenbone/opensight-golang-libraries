<!-- gomarkdoc:embed:start -->

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# esextensions

```go
import "github.com/greenbone/opensight-golang-libraries/pkg/openSearch/esextension"
```

Package esextensions provides extensions for https://github.com/aquasecurity/esquery

## Index

- [type CompositeAgg](<#CompositeAgg>)
  - [func Composite\(name string\) \*CompositeAgg](<#Composite>)
  - [func \(agg \*CompositeAgg\) After\(after map\[string\]string\) \*CompositeAgg](<#CompositeAgg.After>)
  - [func \(agg \*CompositeAgg\) Aggregations\(aggregations ...esquery.Aggregation\) \*CompositeAgg](<#CompositeAgg.Aggregations>)
  - [func \(agg \*CompositeAgg\) Map\(\) map\[string\]interface\{\}](<#CompositeAgg.Map>)
  - [func \(agg \*CompositeAgg\) Name\(\) string](<#CompositeAgg.Name>)
  - [func \(agg \*CompositeAgg\) Size\(size uint64\) \*CompositeAgg](<#CompositeAgg.Size>)
  - [func \(agg \*CompositeAgg\) Sources\(sources ...esquery.Mappable\) \*CompositeAgg](<#CompositeAgg.Sources>)
- [type MatchQuery](<#MatchQuery>)
  - [func Match\(field string, value interface\{\}\) \*MatchQuery](<#Match>)
  - [func \(mq \*MatchQuery\) Map\(\) map\[string\]interface\{\}](<#MatchQuery.Map>)
- [type NestedQuery](<#NestedQuery>)
  - [func Nested\(field string, q esquery.BoolQuery\) \*NestedQuery](<#Nested>)
  - [func \(nq \*NestedQuery\) Map\(\) map\[string\]interface\{\}](<#NestedQuery.Map>)
- [type ScriptedMetricAggregation](<#ScriptedMetricAggregation>)
  - [func NewScriptedMetricAggregation\(name string, initScript string, mapScript string, combineScript string, reduceScript string\) \*ScriptedMetricAggregation](<#NewScriptedMetricAggregation>)
  - [func \(a \*ScriptedMetricAggregation\) Map\(\) map\[string\]interface\{\}](<#ScriptedMetricAggregation.Map>)
  - [func \(a \*ScriptedMetricAggregation\) Name\(\) string](<#ScriptedMetricAggregation.Name>)
- [type ScriptedSumAggregation](<#ScriptedSumAggregation>)
  - [func ScriptedSumAgg\(name string, script string\) \*ScriptedSumAggregation](<#ScriptedSumAgg>)
  - [func \(a \*ScriptedSumAggregation\) Map\(\) map\[string\]interface\{\}](<#ScriptedSumAggregation.Map>)
  - [func \(a \*ScriptedSumAggregation\) Name\(\) string](<#ScriptedSumAggregation.Name>)
- [type TermsSource](<#TermsSource>)
  - [func Terms\(name string, field string\) \*TermsSource](<#Terms>)
  - [func \(t \*TermsSource\) Map\(\) map\[string\]interface\{\}](<#TermsSource.Map>)
  - [func \(t \*TermsSource\) MissingBucket\(\) \*TermsSource](<#TermsSource.MissingBucket>)
  - [func \(t \*TermsSource\) Order\(order string\) \*TermsSource](<#TermsSource.Order>)


<a name="CompositeAgg"></a>
## type CompositeAgg

CompositeAgg represents a composite aggregation, as described in https://www.elastic.co/guide/en/elasticsearch/reference/7.17/search-aggregations-bucket-composite-aggregation.html . To be used in conjunction with the esquery library https://github.com/aquasecurity/esquery

```go
type CompositeAgg struct {
    // contains filtered or unexported fields
}
```

<a name="Composite"></a>
### func Composite

```go
func Composite(name string) *CompositeAgg
```

Composite creates an aggregation of type "composite".

<a name="CompositeAgg.After"></a>
### func \(\*CompositeAgg\) After

```go
func (agg *CompositeAgg) After(after map[string]string) *CompositeAgg
```

After sets the identification for the entry after which the next results should be returned.

<a name="CompositeAgg.Aggregations"></a>
### func \(\*CompositeAgg\) Aggregations

```go
func (agg *CompositeAgg) Aggregations(aggregations ...esquery.Aggregation) *CompositeAgg
```

Aggregations sets the aggregations to be used for the buckets.

<a name="CompositeAgg.Map"></a>
### func \(\*CompositeAgg\) Map

```go
func (agg *CompositeAgg) Map() map[string]interface{}
```

Map returns a map representation of the CompositeAgg, thus implementing the esquery.Mappable interface. Used for serialization to JSON.

<a name="CompositeAgg.Name"></a>
### func \(\*CompositeAgg\) Name

```go
func (agg *CompositeAgg) Name() string
```

Name returns the name of the aggregation, needed for the esquery.Aggregation interface.

<a name="CompositeAgg.Size"></a>
### func \(\*CompositeAgg\) Size

```go
func (agg *CompositeAgg) Size(size uint64) *CompositeAgg
```

Size sets the maximum number of buckets to return.

<a name="CompositeAgg.Sources"></a>
### func \(\*CompositeAgg\) Sources

```go
func (agg *CompositeAgg) Sources(sources ...esquery.Mappable) *CompositeAgg
```

Sources sets the sources for the buckets.

<a name="MatchQuery"></a>
## type MatchQuery

MatchQuery represents an OpenSearch match part in an OpenSearch query as described in https://www.elastic.co/guide/en/elasticsearch/reference/7.17/query-filter-context.html#query-filter-context-ex

```go
type MatchQuery struct {
    Field string
    Value interface{}
}
```

<a name="Match"></a>
### func Match

```go
func Match(field string, value interface{}) *MatchQuery
```

Match creates a new MatchQuery.

<a name="MatchQuery.Map"></a>
### func \(\*MatchQuery\) Map

```go
func (mq *MatchQuery) Map() map[string]interface{}
```

Map returns a map representation of the MatchQuery, thus implementing the esquery.Mappable interface. Used for serialization to JSON.

<a name="NestedQuery"></a>
## type NestedQuery

NestedQuery represents an OpenSearch nested query.

```go
type NestedQuery struct {
    Path  string            `json:"path"`
    Query esquery.BoolQuery `json:"query"`
}
```

<a name="Nested"></a>
### func Nested

```go
func Nested(field string, q esquery.BoolQuery) *NestedQuery
```

Nested creates a new NestedQuery.

<a name="NestedQuery.Map"></a>
### func \(\*NestedQuery\) Map

```go
func (nq *NestedQuery) Map() map[string]interface{}
```

Map returns a map representation of the NestedQuery, thus implementing the esquery.Mappable interface. Used for serialization to JSON.

<a name="ScriptedMetricAggregation"></a>
## type ScriptedMetricAggregation

ScriptedMetricAggregation represents a scripted\_metric aggregation for Elasticsearch.

```go
type ScriptedMetricAggregation struct {
    // contains filtered or unexported fields
}
```

<a name="NewScriptedMetricAggregation"></a>
### func NewScriptedMetricAggregation

```go
func NewScriptedMetricAggregation(name string, initScript string, mapScript string, combineScript string, reduceScript string) *ScriptedMetricAggregation
```

ScriptedMetricAgg is a function that creates a new instance of ScriptedMetricAggregation. It takes the name, init script, map script, combine script, and reduce script as parameters and returns a pointer to the ScriptedMetricAggregation struct.

Example usage:

```
a := NewScriptedMetricAggregation("unique_asset_ids", initScript, mapScript, combineScript, reduceScript)
```

<a name="ScriptedMetricAggregation.Map"></a>
### func \(\*ScriptedMetricAggregation\) Map

```go
func (a *ScriptedMetricAggregation) Map() map[string]interface{}
```

Map returns a map representation of the ScriptedMetricAggregation, thus implementing the esquery.Mappable interface. Used for serialization to JSON.

<a name="ScriptedMetricAggregation.Name"></a>
### func \(\*ScriptedMetricAggregation\) Name

```go
func (a *ScriptedMetricAggregation) Name() string
```

Name returns the name of the ScriptedMetricAggregation, needed for the esquery.Aggregation interface.

<a name="ScriptedSumAggregation"></a>
## type ScriptedSumAggregation

ScriptedSumAggregation represents an aggregation that calculates the sum using a scripted expression. See https://www.elastic.co/guide/en/elasticsearch/reference/7.17/search-aggregations-metrics-sum-aggregation.html#_script_14 . To be used in conjunction with the esquery library https://github.com/aquasecurity/esquery

```go
type ScriptedSumAggregation struct {
    // contains filtered or unexported fields
}
```

<a name="ScriptedSumAgg"></a>
### func ScriptedSumAgg

```go
func ScriptedSumAgg(name string, script string) *ScriptedSumAggregation
```

ScriptedSumAgg is a function that creates a new instance of ScriptedSumAggregation. It takes the name and script as parameters and returns a pointer to the ScriptedSumAggregation struct. Example usage:

```
a := ScriptedSumAgg("testName", "testScript")
```

<a name="ScriptedSumAggregation.Map"></a>
### func \(\*ScriptedSumAggregation\) Map

```go
func (a *ScriptedSumAggregation) Map() map[string]interface{}
```

Map returns a map representation of the ScriptedSumAggregation, thus implementing the esquery.Mappable interface. Used for serialization to JSON.

<a name="ScriptedSumAggregation.Name"></a>
### func \(\*ScriptedSumAggregation\) Name

```go
func (a *ScriptedSumAggregation) Name() string
```

Name returns the name of the ScriptedSumAggregation, needed for the esquery.Aggregation interface.

<a name="TermsSource"></a>
## type TermsSource

TermsSource represents a terms value source in composite aggregations.

```go
type TermsSource struct {
    // contains filtered or unexported fields
}
```

<a name="Terms"></a>
### func Terms

```go
func Terms(name string, field string) *TermsSource
```

Terms creates a new TermsSource.

name: The name of the terms TermsSource. field: The name of the field referenced.

<a name="TermsSource.Map"></a>
### func \(\*TermsSource\) Map

```go
func (t *TermsSource) Map() map[string]interface{}
```

Map returns a map representation of the TermsSource.

<a name="TermsSource.MissingBucket"></a>
### func \(\*TermsSource\) MissingBucket

```go
func (t *TermsSource) MissingBucket() *TermsSource
```

MissingBucket sets the missing\_bucket flag to true in the TermsSource.

<a name="TermsSource.Order"></a>
### func \(\*TermsSource\) Order

```go
func (t *TermsSource) Order(order string) *TermsSource
```

Order sets the sorting order for the TermsSource. Valid values: "asc", "desc".

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)


<!-- gomarkdoc:embed:end -->

# License

Copyright (C) 2022-2023 [Greenbone AG][Greenbone AG]

Licensed under the [GNU General Public License v3.0 or later](../../../LICENSE).